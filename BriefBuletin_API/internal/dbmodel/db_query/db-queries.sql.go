// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: db-queries.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const activateUser = `-- name: ActivateUser :exec
UPDATE news.users
SET user_valid = true WHERE email = $1
`

func (q *Queries) ActivateUser(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, activateUser, email)
	return err
}

const approvalDueListOfComments = `-- name: ApprovalDueListOfComments :many
SELECT c.id AS comment_id, a.title , a."content" AS news,
c.user_name, c.user_email , c."content" AS comment 
FROM news."comments" c 
JOIN news.articles a ON a.id = c.article_id 
WHERE c.is_approved = false
`

type ApprovalDueListOfCommentsRow struct {
	CommentID int32  `db:"comment_id" json:"comment_id"`
	Title     string `db:"title" json:"title"`
	News      string `db:"news" json:"news"`
	UserName  string `db:"user_name" json:"user_name"`
	UserEmail string `db:"user_email" json:"user_email"`
	Comment   string `db:"comment" json:"comment"`
}

func (q *Queries) ApprovalDueListOfComments(ctx context.Context) ([]ApprovalDueListOfCommentsRow, error) {
	rows, err := q.db.Query(ctx, approvalDueListOfComments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApprovalDueListOfCommentsRow
	for rows.Next() {
		var i ApprovalDueListOfCommentsRow
		if err := rows.Scan(
			&i.CommentID,
			&i.Title,
			&i.News,
			&i.UserName,
			&i.UserEmail,
			&i.Comment,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const approveArticle = `-- name: ApproveArticle :exec

UPDATE news.articles
SET status = 'published' WHERE id =$1
`

// OFFSET $1 LIMIT $2;
func (q *Queries) ApproveArticle(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, approveArticle, id)
	return err
}

const approveComment = `-- name: ApproveComment :one
UPDATE news.comments 
SET is_approved = true WHERE id = $1 
RETURNING id, article_id, user_name, user_email, content, is_approved, created_at
`

func (q *Queries) ApproveComment(ctx context.Context, id int32) (NewsComment, error) {
	row := q.db.QueryRow(ctx, approveComment, id)
	var i NewsComment
	err := row.Scan(
		&i.ID,
		&i.ArticleID,
		&i.UserName,
		&i.UserEmail,
		&i.Content,
		&i.IsApproved,
		&i.CreatedAt,
	)
	return i, err
}

const checkCategoryExists = `-- name: CheckCategoryExists :one
SELECT EXISTS(
    SELECT 1 FROM news.categories 
    WHERE id = $1
)
`

func (q *Queries) CheckCategoryExists(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkCategoryExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkCategoryInUse = `-- name: CheckCategoryInUse :one
SELECT EXISTs(
    SELECT 1 FROM news.articles
    WHERE category_id = $1
)
`

func (q *Queries) CheckCategoryInUse(ctx context.Context, categoryID int32) (bool, error) {
	row := q.db.QueryRow(ctx, checkCategoryInUse, categoryID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkCategorySlugExists = `-- name: CheckCategorySlugExists :one
SELECT EXISTS(
    SELECT 1 FROM news.categories 
    WHERE slug = $1 OR name = $2
)
`

type CheckCategorySlugExistsParams struct {
	Slug string `db:"slug" json:"slug"`
	Name string `db:"name" json:"name"`
}

func (q *Queries) CheckCategorySlugExists(ctx context.Context, arg CheckCategorySlugExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkCategorySlugExists, arg.Slug, arg.Name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO news.categories (name, slug)
VALUES ($1, $2) RETURNING id, name, slug, created_at
`

type CreateCategoryParams struct {
	Name string `db:"name" json:"name"`
	Slug string `db:"slug" json:"slug"`
}

// --------------------- Category DATA ------------------------------
func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (NewsCategory, error) {
	row := q.db.QueryRow(ctx, createCategory, arg.Name, arg.Slug)
	var i NewsCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
	)
	return i, err
}

const createCommentWithDefaults = `-- name: CreateCommentWithDefaults :one
INSERT INTO news.comments (article_id, user_name, user_email, content, is_approved)
VALUES ($1, $2, $3, $4, true)
RETURNING id, article_id, user_name, user_email, content, is_approved, created_at
`

type CreateCommentWithDefaultsParams struct {
	ArticleID int32  `db:"article_id" json:"article_id"`
	UserName  string `db:"user_name" json:"user_name"`
	UserEmail string `db:"user_email" json:"user_email"`
	Content   string `db:"content" json:"content"`
}

// ----------------- Comments Data ---------------------------------
func (q *Queries) CreateCommentWithDefaults(ctx context.Context, arg CreateCommentWithDefaultsParams) (NewsComment, error) {
	row := q.db.QueryRow(ctx, createCommentWithDefaults,
		arg.ArticleID,
		arg.UserName,
		arg.UserEmail,
		arg.Content,
	)
	var i NewsComment
	err := row.Scan(
		&i.ID,
		&i.ArticleID,
		&i.UserName,
		&i.UserEmail,
		&i.Content,
		&i.IsApproved,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO news.users(user_name, email, phone, pass, otp, user_valid, otp_exp, role) 
VALUES($1, $2, $3, $4, $5, false, $6, $7)
`

type CreateUserParams struct {
	UserName string           `db:"user_name" json:"user_name"`
	Email    string           `db:"email" json:"email"`
	Phone    string           `db:"phone" json:"phone"`
	Pass     string           `db:"pass" json:"pass"`
	Otp      string           `db:"otp" json:"otp"`
	OtpExp   pgtype.Timestamp `db:"otp_exp" json:"otp_exp"`
	Role     string           `db:"role" json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.UserName,
		arg.Email,
		arg.Phone,
		arg.Pass,
		arg.Otp,
		arg.OtpExp,
		arg.Role,
	)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM news.categories WHERE id = $1
`

func (q *Queries) DeleteCategory(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCategory, id)
	return err
}

const disableComment = `-- name: DisableComment :one
UPDATE news.comments 
SET is_approved = false WHERE id = $1 
RETURNING id, article_id, user_name, user_email, content, is_approved, created_at
`

func (q *Queries) DisableComment(ctx context.Context, id int32) (NewsComment, error) {
	row := q.db.QueryRow(ctx, disableComment, id)
	var i NewsComment
	err := row.Scan(
		&i.ID,
		&i.ArticleID,
		&i.UserName,
		&i.UserEmail,
		&i.Content,
		&i.IsApproved,
		&i.CreatedAt,
	)
	return i, err
}

const draftArticle = `-- name: DraftArticle :exec
UPDATE news.articles
SET status = 'draft' WHERE id =$1
`

func (q *Queries) DraftArticle(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, draftArticle, id)
	return err
}

const getAllCategory = `-- name: GetAllCategory :many
SELECT id, name, slug, created_at from news.categories ORDER BY name
`

func (q *Queries) GetAllCategory(ctx context.Context) ([]NewsCategory, error) {
	rows, err := q.db.Query(ctx, getAllCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsCategory
	for rows.Next() {
		var i NewsCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT user_id, user_name, email 
FROM news.users 
ORDER BY user_id
`

type GetAllUsersRow struct {
	UserID   int32  `db:"user_id" json:"user_id"`
	UserName string `db:"user_name" json:"user_name"`
	Email    string `db:"email" json:"email"`
}

func (q *Queries) GetAllUsers(ctx context.Context) ([]GetAllUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersRow
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(&i.UserID, &i.UserName, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApprovedBanArticles = `-- name: GetApprovedBanArticles :many
SELECT id, title, summary, content, featured_image, category_id, status, published_at, views_count, created_at, updated_at, source_url FROM news.articles
WHERE status = 'published' AND category_id= 7 ORDER BY published_at DESC
OFFSET $1 LIMIT $2
`

type GetApprovedBanArticlesParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) GetApprovedBanArticles(ctx context.Context, arg GetApprovedBanArticlesParams) ([]NewsArticle, error) {
	rows, err := q.db.Query(ctx, getApprovedBanArticles, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsArticle
	for rows.Next() {
		var i NewsArticle
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Summary,
			&i.Content,
			&i.FeaturedImage,
			&i.CategoryID,
			&i.Status,
			&i.PublishedAt,
			&i.ViewsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApprovedCommentsByArticle = `-- name: GetApprovedCommentsByArticle :many
SELECT id, article_id, user_name, user_email, content, is_approved, created_at FROM news.comments 
WHERE article_id = $1 AND is_approved = true 
ORDER BY created_at DESC
`

func (q *Queries) GetApprovedCommentsByArticle(ctx context.Context, articleID int32) ([]NewsComment, error) {
	rows, err := q.db.Query(ctx, getApprovedCommentsByArticle, articleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsComment
	for rows.Next() {
		var i NewsComment
		if err := rows.Scan(
			&i.ID,
			&i.ArticleID,
			&i.UserName,
			&i.UserEmail,
			&i.Content,
			&i.IsApproved,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApprovedEngArticles = `-- name: GetApprovedEngArticles :many
SELECT id, title, summary, content, featured_image, category_id, status, published_at, views_count, created_at, updated_at, source_url FROM news.articles
WHERE status = 'published' AND category_id != 7 ORDER BY published_at DESC
OFFSET $1 LIMIT $2
`

type GetApprovedEngArticlesParams struct {
	Offset int32 `db:"offset" json:"offset"`
	Limit  int32 `db:"limit" json:"limit"`
}

func (q *Queries) GetApprovedEngArticles(ctx context.Context, arg GetApprovedEngArticlesParams) ([]NewsArticle, error) {
	rows, err := q.db.Query(ctx, getApprovedEngArticles, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsArticle
	for rows.Next() {
		var i NewsArticle
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Summary,
			&i.Content,
			&i.FeaturedImage,
			&i.CategoryID,
			&i.Status,
			&i.PublishedAt,
			&i.ViewsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticleDetails = `-- name: GetArticleDetails :one

SELECT id, title, summary, content, featured_image, category_id, status, published_at, views_count, created_at, updated_at, source_url FROM news.articles
WHERE id = $1
`

// ------------------- Article Service ------------------------------
func (q *Queries) GetArticleDetails(ctx context.Context, id int32) (NewsArticle, error) {
	row := q.db.QueryRow(ctx, getArticleDetails, id)
	var i NewsArticle
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.FeaturedImage,
		&i.CategoryID,
		&i.Status,
		&i.PublishedAt,
		&i.ViewsCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SourceUrl,
	)
	return i, err
}

const getCategory = `-- name: GetCategory :one
SELECT id, name, slug, created_at FROM news.categories WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCategory(ctx context.Context, id int32) (NewsCategory, error) {
	row := q.db.QueryRow(ctx, getCategory, id)
	var i NewsCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
	)
	return i, err
}

const getPendingComments = `-- name: GetPendingComments :many
SELECT id, article_id, user_name, user_email, content, is_approved, created_at FROM news.comments 
WHERE is_approved = false 
ORDER BY created_at DESC
`

func (q *Queries) GetPendingComments(ctx context.Context) ([]NewsComment, error) {
	rows, err := q.db.Query(ctx, getPendingComments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsComment
	for rows.Next() {
		var i NewsComment
		if err := rows.Scan(
			&i.ID,
			&i.ArticleID,
			&i.UserName,
			&i.UserEmail,
			&i.Content,
			&i.IsApproved,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodaysBnNews = `-- name: GetTodaysBnNews :many
SELECT id, title, summary, content, featured_image, category_id, status, published_at, views_count, created_at, updated_at, source_url
FROM news.articles
WHERE status = 'published'
    AND category_id = 7 
    AND published_at >= $1::date
    AND published_at <  $1::date + INTERVAL '1 day'
ORDER BY published_at DESC
`

func (q *Queries) GetTodaysBnNews(ctx context.Context, dollar_1 pgtype.Date) ([]NewsArticle, error) {
	rows, err := q.db.Query(ctx, getTodaysBnNews, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsArticle
	for rows.Next() {
		var i NewsArticle
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Summary,
			&i.Content,
			&i.FeaturedImage,
			&i.CategoryID,
			&i.Status,
			&i.PublishedAt,
			&i.ViewsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodaysEnNews = `-- name: GetTodaysEnNews :many
SELECT id, title, summary, content, featured_image, category_id, status, published_at, views_count, created_at, updated_at, source_url
FROM news.articles
WHERE status = 'published'
    AND category_id != 7 
    AND published_at >= $1::date
    AND published_at <  $1::date + INTERVAL '1 day'
ORDER BY published_at DESC
`

func (q *Queries) GetTodaysEnNews(ctx context.Context, dollar_1 pgtype.Date) ([]NewsArticle, error) {
	rows, err := q.db.Query(ctx, getTodaysEnNews, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsArticle
	for rows.Next() {
		var i NewsArticle
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Summary,
			&i.Content,
			&i.FeaturedImage,
			&i.CategoryID,
			&i.Status,
			&i.PublishedAt,
			&i.ViewsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnApprovedArticleList = `-- name: GetUnApprovedArticleList :many
SELECT id, title, summary, content, featured_image, category_id, status, published_at, views_count, created_at, updated_at, source_url FROM news.articles
WHERE status = 'draft' order BY published_at DESC
`

func (q *Queries) GetUnApprovedArticleList(ctx context.Context) ([]NewsArticle, error) {
	rows, err := q.db.Query(ctx, getUnApprovedArticleList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NewsArticle
	for rows.Next() {
		var i NewsArticle
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Summary,
			&i.Content,
			&i.FeaturedImage,
			&i.CategoryID,
			&i.Status,
			&i.PublishedAt,
			&i.ViewsCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SourceUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, user_name, email, phone, pass, pss_valid, otp, user_valid, otp_exp, role 
FROM news.users 
WHERE email = $1
`

// --------------------- AUTHENTICATION ------------------------------
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (NewsUser, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i NewsUser
	err := row.Scan(
		&i.UserID,
		&i.UserName,
		&i.Email,
		&i.Phone,
		&i.Pass,
		&i.PssValid,
		&i.Otp,
		&i.UserValid,
		&i.OtpExp,
		&i.Role,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT user_id, user_name, email, phone, pass, pss_valid, otp, user_valid, otp_exp, role 
FROM news.users 
WHERE user_id = $1
`

func (q *Queries) GetUserById(ctx context.Context, userID int32) (NewsUser, error) {
	row := q.db.QueryRow(ctx, getUserById, userID)
	var i NewsUser
	err := row.Scan(
		&i.UserID,
		&i.UserName,
		&i.Email,
		&i.Phone,
		&i.Pass,
		&i.PssValid,
		&i.Otp,
		&i.UserValid,
		&i.OtpExp,
		&i.Role,
	)
	return i, err
}

const getUserByLogin = `-- name: GetUserByLogin :one
SELECT user_id, user_name, email, phone, pass, pss_valid, otp, user_valid, otp_exp, role 
FROM news.users 
WHERE user_name = $1 OR email = $1 OR phone = $1
`

func (q *Queries) GetUserByLogin(ctx context.Context, userName string) (NewsUser, error) {
	row := q.db.QueryRow(ctx, getUserByLogin, userName)
	var i NewsUser
	err := row.Scan(
		&i.UserID,
		&i.UserName,
		&i.Email,
		&i.Phone,
		&i.Pass,
		&i.PssValid,
		&i.Otp,
		&i.UserValid,
		&i.OtpExp,
		&i.Role,
	)
	return i, err
}

const getUserByPhone = `-- name: GetUserByPhone :one
SELECT user_id, user_name, email, phone, pass, pss_valid, otp, user_valid, otp_exp, role 
FROM news.users 
WHERE phone = $1
`

func (q *Queries) GetUserByPhone(ctx context.Context, phone string) (NewsUser, error) {
	row := q.db.QueryRow(ctx, getUserByPhone, phone)
	var i NewsUser
	err := row.Scan(
		&i.UserID,
		&i.UserName,
		&i.Email,
		&i.Phone,
		&i.Pass,
		&i.PssValid,
		&i.Otp,
		&i.UserValid,
		&i.OtpExp,
		&i.Role,
	)
	return i, err
}

const getUserByUserName = `-- name: GetUserByUserName :one
SELECT user_id, user_name, email, phone, pass, pss_valid, otp, user_valid, otp_exp, role 
FROM news.users 
WHERE user_name = $1
`

func (q *Queries) GetUserByUserName(ctx context.Context, userName string) (NewsUser, error) {
	row := q.db.QueryRow(ctx, getUserByUserName, userName)
	var i NewsUser
	err := row.Scan(
		&i.UserID,
		&i.UserName,
		&i.Email,
		&i.Phone,
		&i.Pass,
		&i.PssValid,
		&i.Otp,
		&i.UserValid,
		&i.OtpExp,
		&i.Role,
	)
	return i, err
}

const readArticleCount = `-- name: ReadArticleCount :exec
UPDATE news.articles
SET views_count = views_count + 1
WHERE id = $1
`

func (q *Queries) ReadArticleCount(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, readArticleCount, id)
	return err
}

const sendNewOtp = `-- name: SendNewOtp :exec
UPDATE news.users
SET otp = $1, otp_exp = $2 WHERE email = $3
`

type SendNewOtpParams struct {
	Otp    string           `db:"otp" json:"otp"`
	OtpExp pgtype.Timestamp `db:"otp_exp" json:"otp_exp"`
	Email  string           `db:"email" json:"email"`
}

func (q *Queries) SendNewOtp(ctx context.Context, arg SendNewOtpParams) error {
	_, err := q.db.Exec(ctx, sendNewOtp, arg.Otp, arg.OtpExp, arg.Email)
	return err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE news.categories 
SET name = $2, slug = $3 WHERE id = $1 
RETURNING id, name, slug, created_at
`

type UpdateCategoryParams struct {
	ID   int32  `db:"id" json:"id"`
	Name string `db:"name" json:"name"`
	Slug string `db:"slug" json:"slug"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (NewsCategory, error) {
	row := q.db.QueryRow(ctx, updateCategory, arg.ID, arg.Name, arg.Slug)
	var i NewsCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
	)
	return i, err
}

const updatePassword = `-- name: UpdatePassword :exec
UPDATE news.users 
SET pass = $1, pss_valid = $2 
WHERE email = $3
`

type UpdatePasswordParams struct {
	Pass     string `db:"pass" json:"pass"`
	PssValid bool   `db:"pss_valid" json:"pss_valid"`
	Email    string `db:"email" json:"email"`
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, updatePassword, arg.Pass, arg.PssValid, arg.Email)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE news.users 
SET user_name = $1, email = $2, phone = $3, role = $4
WHERE user_id = $5
`

type UpdateUserParams struct {
	UserName string `db:"user_name" json:"user_name"`
	Email    string `db:"email" json:"email"`
	Phone    string `db:"phone" json:"phone"`
	Role     string `db:"role" json:"role"`
	UserID   int32  `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.UserName,
		arg.Email,
		arg.Phone,
		arg.Role,
		arg.UserID,
	)
	return err
}
